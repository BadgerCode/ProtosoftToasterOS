<!doctype html>
<html>

<head>
  <style>
    body {
      background: #1b161e;
      color: white;
      font-family: Inter, SF Pro, Segoe UI, Roboto, Oxygen, Ubuntu, Helvetica Neue, Helvetica, Arial, sans-serif;
    }

    #face {
      display: flex;
      flex-direction: row;
    }

    #outputArea {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #output {
      flex: 1;
      width: 100%;
      background-color: #1e1e1e;
      color: white;
      border: 1px solid black;
      margin-top: 50px;
    }

    select {
      background: #14161a;
      color: white;
      border: 1px solid #353a46;
      padding: 5px 15px;
    }

    button {
      background: #14161a;
      color: white;
      cursor: pointer;
      border: 1px solid #353a46;
      padding: 5px 15px;
    }

    button:disabled,
    button:disabled:hover {
      background: #14161a;
      color: #737373;
      cursor: initial;
    }

    button:hover {
      background: #1f2229;
    }

    #loadButton {
      font-size: 32px;
      padding: 10px 20px;
    }

    #faceSwitcher {
      display: flex;
      flex-direction: row;
      gap: 10px;
      padding: 10px;
    }

    #loadedFacesSelect {
      width: 250px;
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="face">
      <canvas id="faceCanvas" width="1000" height="600" style="border:1px solid #000000;"></canvas>
      <div id="outputArea">
        <div id="faceSwitcher">
          <div>Expression:</div>
          <select id="loadedFacesSelect" :value="currentExpressionName" @change="e => switchFace(e.target.value)">
            <option v-for="name in Object.keys(expressions)">{{name}}</option>
          </select>
        </div>

        <div>
          <button id="toggleBlink">Enable Blink</button>
          <button id="addOrRemoveBlink">Add Blink</button>
        </div>

        <textarea id="output"></textarea>

        <button id="loadButton">Load</button>
      </div>
    </div>
  </div>

  <script>
    // Default faces
    let defaultFaces = [
      `struct FaceExpression Face_Neutral = {
  .Nose = {
    { B00110000, B01110000, B11100000, B11000000, B00000000, B00000000, B00000000, B00000000 }  //
  },
  .Eye = {
    { B00000000, B00000011, B00001111, B00111111, B01111111, B11111111, B11111110, B11100000 },  //
    { B00000000, B11100000, B11111000, B11111100, B11111110, B11111111, B00000000, B00000000 }   //
  },
  .HasBlink = true,
  .Eye_Blink = {
    { B00000000, B00000000, B00000000, B00000111, B00001111, B00111111, B11100000, B00000000 },  //
    { B00000000, B00000000, B00000000, B11000000, B11100000, B11111111, B00000000, B00000000 }   //
  },
  .Mouth = {
    { B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000 },  //
    { B00000000, B00000000, B00000000, B10000000, B01110001, B00011111, B00000011, B00000000 },  //
    { B00000000, B00000000, B00000000, B00100000, B11111111, B11100111, B10000000, B00000000 },  //
    { B00000000, B00000000, B00000111, B01111100, B11110000, B11000000, B00000000, B00000000 }   //
  }
};`,
      `struct FaceExpression Face_Heart = {
  .Nose = {
    { B00110000, B01110000, B11100000, B11000000, B00000000, B00000000, B00000000, B00000000 }  //
  },
  .Eye = {
    { B00000110, B00001111, B00011111, B00011111, B00001111, B00000111, B00000011, B00000001 },  //
    { B11000000, B11100000, B11110000, B11110000, B11100000, B11000000, B10000000, B00000000 }   //
  },
  .HasBlink = false,
  .Eye_Blink = {},
  .Mouth = {
    { B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000 },  //
    { B00000000, B00000000, B10000000, B11000000, B01110000, B00111110, B00001111, B00000000 },  //
    { B00000000, B00000000, B00000000, B00000000, B00011111, B01111111, B11100000, B00000000 },  //
    { B00000000, B00000010, B00001110, B01111100, B11100000, B11000000, B00000000, B00000000 }   //
  }
};`,
      `struct FaceExpression Face_Blep = {
  .Nose = {
    { B00110000, B01110000, B11100000, B11000000, B00000000, B00000000, B00000000, B00000000 }  //
  },
  .Eye = {
    { B00000000, B00000011, B00001111, B00111111, B01111111, B11111111, B11111110, B11100000 },  //
    { B00000000, B11100000, B11111000, B11111100, B11111110, B11111111, B00000000, B00000000 }   //
  },
  .HasBlink = true,
  .Eye_Blink = {
    { B00000000, B00000000, B00000000, B00000111, B00001111, B00111111, B11100000, B00000000 },  //
    { B00000000, B00000000, B00000000, B11000000, B11100000, B11111111, B00000000, B00000000 }   //
  },
  .Mouth = {
    { B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000 },  //
    { B00000000, B11000000, B01111111, B00001111, B00001110, B00000110, B00000011, B00000000 },  //
    { B00000000, B00001111, B11111100, B11100000, B11100000, B11000000, B10000000, B00000000 },  //
    { B00111100, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000 }   //
  }
};`,
      `struct FaceExpression Face_Spiral = {
  .Nose = {
    { B00110000, B01110000, B11100000, B11000000, B00000000, B00000000, B00000000, B00000000 }  //
  },
  .Eye = {
    { B00001111, B00011001, B00110000, B00110010, B00100100, B00110110, B00110011, B00011000 },  //
    { B00000000, B10000000, B11000000, B01000000, B01000000, B11000000, B10000000, B00000000 }   //
  },
  .HasBlink = false,
  .Eye_Blink = {},
  .Mouth = {
    { B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B00000000, B00000000 },  //
    { B00000000, B00000000, B00000000, B00000000, B00001111, B11111111, B00000011, B00000000 },  //
    { B00000000, B00000000, B00000000, B00000000, B11111111, B11100111, B10000000, B00000000 },  //
    { B00000000, B00000000, B00000111, B01111100, B11110000, B11000000, B00000000, B00000000 }   //
  }
};`
    ];
  </script>


  <script type="module">
    import { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
    const dotSize = 20;
    let clickableLights = {};
    let showBlink = false;

    // Current loaded expression
    // Saved expressions
    createApp({
      setup() {
        return {
          currentExpressionName: ref("Face_Name"),
          expressions: ref({}),
          currentExpression: ref({})
        }
      },
      mounted() {
        // Register events
        // TOGGLE BLINK
        document.getElementById("toggleBlink").addEventListener("click", (e) => {
          showBlink = !showBlink;
          this.drawFace();
          this.UpdateBlinkButton();
        });

        // Add or remove blink
        document.getElementById("addOrRemoveBlink").addEventListener("click", (e) => {
          this.AddOrRemoveBlink();
        });


        // Click load
        loadButton.addEventListener('click', () => {
          this.parseWholeFace(document.getElementById("output").value);
        });


        // Canvas interaction
        faceCanvas.addEventListener('click', (e) => {
          const rect = faceCanvas.getBoundingClientRect()
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          let dotX = Math.floor((x + dotSize / 2) / dotSize);
          let dotY = Math.floor((y + dotSize / 2) / dotSize);

          let dot = clickableLights[`${dotX},${dotY}`];
          if (dot) {
            dot.pattern[dot.row][dot.column] = 1 - dot.pattern[dot.row][dot.column];
            this.drawFace();
          }
        });



        // Load default faces and set initial face
        for (const face of defaultFaces) {
          this.parseWholeFace(face);
        }

        this.switchFace(Object.keys(this.expressions)[0]);
      },
      methods: {
        // FACE SWITCHER
        UpdateBlinkButton() {
          toggleBlink.innerHTML = showBlink ? "Disable Blink" : "Enable Blink";
          toggleBlink.disabled = !this.currentExpression.hasBlink;
        },

        UpdateAddOrRemoveBlinkButton() {
          addOrRemoveBlink.innerHTML = this.currentExpression.hasBlink ? "Remove Blink" : "Add Blink";
        },


        switchFace(facename) {
          this.currentExpression = this.expressions[facename];
          this.currentExpressionName = facename;

          showBlink = false;
          this.UpdateBlinkButton();
          this.UpdateAddOrRemoveBlinkButton();

          this.drawFace();
        },

        AddOrRemoveBlink() {
          // If we're removing the blink
          if (this.currentExpression.hasBlink) {
            if (confirm("Are you sure you want to remove the blink? This can't be undone") == false) return;
          }

          this.currentExpression.hasBlink = !this.currentExpression.hasBlink;

          this.currentExpression.eyeBlinkPatterns.splice(0);
          if (this.currentExpression.hasBlink) {
            // Deep copy the non-blink eye
            this.currentExpression.eyeBlinkPatterns = this.currentExpression.eyePatterns.map(panel => panel.map(row => row.slice()));
          }

          // Stop showing or immediately show the new blink
          showBlink = this.currentExpression.hasBlink;
          this.UpdateBlinkButton();
          this.UpdateAddOrRemoveBlinkButton();

          this.drawFace();
        },




        // CODE OUTPUT
        updateOutput() {
          let output = document.getElementById("output");

          let blinkOutput = !this.currentExpression.hasBlink ? "{}" : `{
    { ${this.patternToMatrixString(this.currentExpression.eyeBlinkPatterns[0])} },  //
    { ${this.patternToMatrixString(this.currentExpression.eyeBlinkPatterns[1])} }   //
  }`;

          output.value = `struct FaceExpression ${this.currentExpressionName} = {
  .Nose = {
    { ${this.patternToMatrixString(this.currentExpression.nosePatterns[0])} }  //
  },
  .Eye = {
    { ${this.patternToMatrixString(this.currentExpression.eyePatterns[0])} },  //
    { ${this.patternToMatrixString(this.currentExpression.eyePatterns[1])} }   //
  },
  .HasBlink = ${this.currentExpression.hasBlink},
  .Eye_Blink = ${blinkOutput},
  .Mouth = {
    { ${this.patternToMatrixString(this.currentExpression.mouthPatterns[0])} },  //
    { ${this.patternToMatrixString(this.currentExpression.mouthPatterns[1])} },  //
    { ${this.patternToMatrixString(this.currentExpression.mouthPatterns[2])} },  //
    { ${this.patternToMatrixString(this.currentExpression.mouthPatterns[3])} }   //
  }
};`;
        },

        patternToMatrixString(pattern) {
          return pattern.map(row => `B${row.join("")}`).join(", ");
        },




        // CODE INPUT


        // Load a face & switch to it
        parseWholeFace(input) {
          let lines = input.trim().split("\n");
          let newExpressionName = lines[0].replace(/.*FaceExpression ([^ =]+) =.*/, "$1");

          let pattern = /\s+\{\s(.*)\s\},?\s+\/\//;

          let nosePatterns = [
            this.parseMatrixPattern(lines[2].replace(pattern, "$1")),
          ];

          let eyePatterns = [
            this.parseMatrixPattern(lines[5].replace(pattern, "$1")),
            this.parseMatrixPattern(lines[6].replace(pattern, "$1")),
          ];

          let hasBlink = lines[8].includes("true");
          let eyeBlinkPatterns = [];
          if (hasBlink) {
            eyeBlinkPatterns = [
              this.parseMatrixPattern(lines[10].replace(pattern, "$1")),
              this.parseMatrixPattern(lines[11].replace(pattern, "$1")),
            ];
          }

          let offset = hasBlink ? 3 : 0;
          let mouthPatterns = [
            this.parseMatrixPattern(lines[11 + offset].replace(pattern, "$1")),
            this.parseMatrixPattern(lines[12 + offset].replace(pattern, "$1")),
            this.parseMatrixPattern(lines[13 + offset].replace(pattern, "$1")),
            this.parseMatrixPattern(lines[14 + offset].replace(pattern, "$1")),
          ];

          this.expressions[newExpressionName] = {
            nosePatterns: nosePatterns,
            eyePatterns: eyePatterns,
            hasBlink: hasBlink,
            eyeBlinkPatterns: eyeBlinkPatterns,
            mouthPatterns: mouthPatterns
          };

          this.currentExpression = this.expressions[newExpressionName];
          this.currentExpressionName = newExpressionName;

          this.drawFace();
        },

        parseMatrixPattern(patternString) {
          return patternString.split(",")
            .map(row =>
              row.trim().replace("B", "")
                .split("")
                .map(bit => parseInt(bit))
            );
        },




        // FACE RENDERING
        drawFace() {
          let face = this.currentExpression;
          let ctx = faceCanvas.getContext("2d");
          ctx.clearRect(0, 0, faceCanvas.width, faceCanvas.height);

          this.drawGrid(ctx, 40, 200, face.nosePatterns[0]);
          this.drawPanelBox(ctx, 40, 200, 1);

          this.drawGrid(ctx, 500, 40, (showBlink && face.hasBlink) ? face.eyeBlinkPatterns[0] : face.eyePatterns[0]);
          this.drawGrid(ctx, 500 + (dotSize * 8), 40, (showBlink && face.hasBlink) ? face.eyeBlinkPatterns[1] : face.eyePatterns[1]);
          this.drawPanelBox(ctx, 500, 40, 2);

          this.drawGrid(ctx, 140, 400, face.mouthPatterns[0]);
          this.drawGrid(ctx, 140 + (dotSize * 8), 400, face.mouthPatterns[1]);
          this.drawGrid(ctx, 140 + (dotSize * 8) * 2, 400, face.mouthPatterns[2]);
          this.drawGrid(ctx, 140 + (dotSize * 8) * 3, 400, face.mouthPatterns[3]);
          this.drawPanelBox(ctx, 140, 400, 4);

          this.updateOutput();
        },

        drawDot(ctx, x, y, size) {
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, 2 * Math.PI);
          ctx.fillStyle = "#0099FF";
          ctx.fill();
        },

        drawPanelBox(ctx, x, y, numMatrices) {
          ctx.beginPath();
          ctx.rect(x - (dotSize / 2) - 1, y - (dotSize / 2) - 1, dotSize * 8 * numMatrices + 2, dotSize * 8 + 2);
          ctx.strokeStyle = "#444";
          ctx.stroke();
        },

        drawGrid(ctx, startX, startY, pattern) {
          for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
              let x = startX + (j * dotSize);
              let y = startY + (i * dotSize);

              if (pattern[i][j])
                this.drawDot(ctx, x, y, dotSize);

              let clickX = x / dotSize;
              let clickY = y / dotSize;
              clickableLights[`${clickX},${clickY}`] = { pattern: pattern, row: i, column: j };
            }

          }
        }
      }
    }).mount('#app')



  </script>
</body>

</html>